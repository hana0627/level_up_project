# Level_up_project - 간단한 상품거래 도메인에 스프링기술 적용하기

---

## 프로젝트 개요
참여인원 : 1명

사용기술 : Java, SpringBoot, JPA, MariaDB, Thymeleaf

담당업무 :
  로그인 - 로그인시 쿠키발행
  권한 관리 - 인터셉터를 이용한 접근권한 제어
  AOP - 프록시를 이용한 시간측정 로직 작성
  회원관리 - 회원관련 비지니스 로직 작성
  상품관리 - 상품관련 비지니스 로직 작성
  주문관리 - 주문관련 비지니스 로직 작성

---
## 프로젝트 기획

1. DB설계
https://docs.google.com/spreadsheets/d/1vs1fOuw1tlL-uvm5RgJg5JSpFH4-5eahY8TyK9JSZR8/edit#gid=0

db설계는 스프레드 시트를 이용하여 작성하였습니다.

![디비디비딥.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/527c266e-ab7e-4955-82a1-088a91ca9e97/%EB%94%94%EB%B9%84%EB%94%94%EB%B9%84%EB%94%A5.png)

기본적으로 hibernate의 ddl-auto 기능을 update로 설정하여 기본적인 테이블 틀을 만들고, 필요한 부분은 HeidiSQL을 이용하여 수정해서 사용하였습니다.(Enum Type으로 정의된 컬럼이 의도와 다르게 INT타입으로 설정되어 VARCHAR로 타입변경을 하였습니다.)


2. URL 설계
https://docs.google.com/spreadsheets/d/1vs1fOuw1tlL-uvm5RgJg5JSpFH4-5eahY8TyK9JSZR8/edit#gid=1961272708
![유알엘.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a678295-e910-431e-afcb-6008fc424146/%EC%9C%A0%EC%95%8C%EC%97%98.png)

처음에는 설계없이 나름의 규칙을 가지고 그때그때 적합한 url을 설계하였으나, 후에 상품판매자와 구매자가 같은 ‘products/*’  형식의 url을 공유하면서 점점 url구조가 산으로 가는 현상이 있었습니다.

개인프로젝트이다 보니까 큰 문제없이 적당히 수습하였으나, 협업으로 진행하는 프로젝트였다면 끔찍한 일이 발생했을것 같습니다.

또한 api정의서 없이 그때그때 생각나는대로 개발한다면, 개발할 당시에는 편하지만, 차후에라도 그것을 문서화 하지 않으면 후에 운영환에서 유지보수하기 끔찍해지겠다는 생각이 들었습니다.

---

## trouble shooting

**1. Interceptor를 적용하면서 특정 URL 접근시 ‘리디렉션한 횟수가 너무 많습니다. ‘ 현상 발생.**

  특정 url에서 결과를 만족시키지 못했을때 다른 url로 이동하게끔 작성하였습니다.
  하지만 해당 url이 다시한번 interceptor를 호출하였으며, 조건을 만족시키지 못하여 또다시 intercepor를 호출하는 무한루프를 발생시키는 현상이였습니다.
  **→ excludePatterns에 문제가 되는 경로를 추가하여 해결하였습니다.**


**2. AOP 적용시 Service에서 반환한 값이 항상 null이 나오는 현상 발생.**

  Service 계층에서 비지니스 로직의 시간을 측정하는 aop를 적용하였습니다.
  하지만, aop적용이후 service 안에서는 분명 값이있었는데 controller에서는 항상 null로 반환되는 이슈가 있었습니다..
  시간측정 aop는 단순히 로직에 대한 시간만 측정하면 된다고 생각하여 리턴값이 없는 void로 작성하여 결과값이 항상 null이 나오는 문제였습니다.
  **→ 프록시에서 실행한 결과를 Obejct로 반환받아 해당 값을 return 해줌으로써 해당 문제를 해결하였습니다.**


**3. Products/* url의 중복문제 발생. **
  api 정의에 대한 중요성을 느끼지 못하고,  확실하게 설계하지 않고 즉흥적으로 url을 설계하였습니다.
  일반 사용자와 판매자는 같은 products 하위의 url을 사용하는 바람에 url 구조가 엉망진창이 되버렸습니다.
  **→ url을 ‘products/seller’, ‘products/member’ 로  나누어 작성하였습니다.**
  **회고)** url을 공유하며 쿠키에 저장된 회원정보를 이용하여,
  조건문을 사용해 사용자 정보에 따라서 다른 로직을 실행하는 방법에 대해서도 고민하였습니다.
  하지만 컨트롤러에서 항상 member를 조회함으로 코드가 길어지고,
  컨트롤러는 더이상 단순히 Service를 연결하는 역할만이 있는것이 아닌 member에 대해서 알아야 하는 역할이 생기게 된다고 판단하여 url을 분리하였습니다.


**4. 영속성컨텍스트 초기화 문제**
  의도와 다르게 insert쿼리가 실행되지 않고 update쿼리만 나가는 현상이 있었습니다.
  엔티티 설계 당시 삭제나 변동사항이 있을경우 해당 엔티티를 직접 제어 하는 것이 아닌, isVisble 컬럼을 false 으로 처리하고 새로운 정보를 다시 insert 하는 전략을 택하였습니다.
  주문로직을 작성하면서 기존 상품에 대하여 isVisible을 false로 처리하고, 다시 등록하려는데 새롭게 등록하고자 하는 객체를  entityManager의 1차캐시에서 조회하는 바람에 같은 객체로 인식하여 의도대로 쿼리가 나가지 않는 현상 이였습니다.
   **→ dto객체를 만들어 새로 등록할 정보를 dto에 저장한 후, 해당 dto를 entity로 반환하여 저장하였습니다.**

  **회고)** 영속성컨텍스트를 직접 초기화하는 방법에 대해서도 고민해보았습니다.
  해당방법 사용시, 파라미터로 넘어온 인자를 통하여 다시 한번 조회쿼리를 실행하여야 했으며,
  중복되는 코드가 발생할 것으로 판단하여 조회한 정보를 dto객체에 담는 방법을 택했습니다.


**5. hibernate 불필요한 update쿼리가 나가는 현상 발생**
  insert쿼리가 한번 나갈것으로 의도한 쿼리가 insert쿼리 한번, update 쿼리 한번 총 두번나가는 현상이 있었습니다.
  service단에 너무 많은 책임이 들어있는것 같아서 상태 변경에 대한 역할은 도메인으로 옮겨서 발생한 문제였습니다.
  
  insert문으로 조회한 후, 해당 엔티티에 상태변경 메소드를 사용하여 값을 변경하면, 같은 트랜젝션 안에서 jpa가 마법처럼 insert쿼리 한방으로 만들어 줄 것이라고 생각했으나, 그렇지 않은 결과였습니다.
 **→ BaseEntity에 @PrePersist를 통하여기본값을 설정해주었습니다.**

  **회고)** 처음에는 Column(default='') 어노테이션을 사용하여 해결하려 하였습니다.
하지만 default 벨류에 boolean 값을 설정할 수 없어서 문제해결에 시간이 걸렸습니다.

        더불어 @Builder.default 어노테이션을 사용하여 해결하는 방법도 찾았습니다.
        짧은 견해이지만, 굳이 lombok의 기능을 사용하는것 보단 hibernate에서 제공하는 기능을 사용하는게 더 깔끔하다고 생각하였고,
        여러 JPA교재에 소개되어있는 @PrePersist  와는 달리 @Builder.default 은 구글검색을 통하여 처음 본 어노테이션이였습니다.

       후에 유지보수를 쉽게 하기 위해선 조금이라도 더 알려진 어노테이션을 사용하는것이 올바른 방향이라 생각해서 @PrePersist을 사용했습니다.


**6. SpringSecurity 적용 후 Post 요청이 적용되지 않는 현상 발생**
  스프링 시큐리티 적용 후 GET요청에서는 의도적인 흐름대로 어플리케이션이 진행되나, POST요청만 만나면 컨트롤러도 거치지 않은 채 403 Forbidden 에러를 만났습니다.
  → 설정 클래스에 http.csrf().disable(); 설정을 추가하였습니다.
  추가적으로 찾아본 결과 스프링시큐리티는 CSRF공격에 대한 방지를 수행한다고 합니다.  따라서 해당 기능을 disable하면 해당 문제가 해결되었습니다.

  **그러나** 어플리케이션의 흐름을 의도대로 진행하기 위하여 기본적인 보안기능을 disable하는 방식은 별로 올바르지 않은 방법인것 같습니다.
  → http.csrf().disable(); 선언 후 인터셉터에서 추가적인 검증을 진행하거나, 쿠키대신 JWT를 이용하는 방식 등으로 해결이 가능하다고 합니다.
  아직은 해당 기능까지 염두하여 개발하면 더욱 좋겠지만, 저의 기술력으로는 다소 허들이 있다고 생각합니다.
  추가적인 학습을 진행하여  추후에는 해당 이슈까지 완벽하게 다뤄보고 싶습니다.
  
---

## 프로젝트를 진행하면서

**1. 자바, 스프링의 기본기를 다잡았습니다.** 
  이론만 계속 공부하기보다는 공부한 내용을 실제로 적용하기 위하여 시작한 프로젝트 입니다.
  aop, intercepter 등 스프링의 핵심기능을 global 패키지 안에 작성한 후 WebConfig를 통해 적용했습니다.

 간단한 예제임에도 의도와 다르게 실제 적용에 어려움을 겪기도 하였습니다.

 스프링의 기본기를 다잡는것이 목표인 프로젝트 인만큼, 단순한 문제해결보단 ‘왜 이러한 문제가 발생하였는지, 어떻게 해결하여야 하는지’를 알아가는것에 초점을 두고
 이론을 다시공부하고, 적용하는 과정을 반복했습니다.

~~**2.객체지향적인 코드를 만들기위해 노력하였습니다. **~~
아직 많이 부족하지만, 각 객체에 최소한의 책임만을 할당하도록 노력하였습니다.

 Controller에서 비지니스로직은 철저히 Service에 위임하고, 반환 결과를 전달하는 역할만을

 Service 계층에서는 비지니스 로직만을 처리하였으며,

 Repository 계층에는 철저히 db와 커넥션만 하는 역할을 수행하게끔 작성하였습니다.


**3. dto의 필드를 public으로 선언 해보았습니다.**
  “DTO는 상태를 보호하지 않으며 모든 속성을 노출하므로 획득자와 설정자가 필요없다. 이는 public 속성으로 충분하다는 뜻이다.” - 미티아스 노박. 오브젝트 디자인 스타일 가이드

최근 강의를 들으면서 강사가 인용한 내용입니다.
dto는 데이터를 주고받을때, 변수를 하나하나 일일히 전달하기 힘드니까 그냥 데이터를 묶는 객체일 뿐이다. 라고 하여 한번 적용해 보았습니다.
정보를 불러올때 getter가 아닌 직접 가지고 오는것이 아직은 어색하지만, 단순히 데이터를 가공하는 객체의 필드를 private로 선언하는 행동자체가 무의미하다는 생각이 들었습니다.

습관적으로 getter와 setter를 사용해왔는데, 이렇게 당연하고 간단한 부분에 대해서 의문을 품지 않은것이 부끄럽습니다.
그러나 많은 개발자들이 dto에 필드에 private를 사용하는것에는 다른 이유가 있을것이라 생각합니다. 추가적으로 학습 해보겠습니다!

**회고)** 의도와는 다르게 필드를 public으로 선언한 dto에 대해서는 인자값이 들어오지 않는 현상이 발견되었습니다.
한참을 고민하며 고친결과 @Getter @Setter 어노테이션을 추가하니 정상 작동되는 모습이였습니다.
@ModelAttribute 사용시 getter 와 setter를 이용하여 인자를 전달받는것을 알게되었습니다.
기껏 필드를 public으로 선언해놓고, getter와 setter를 사용한다니.. 조금 더 깊게 알고싶어졌습니다.

저자는 어떤의도에서 저런 언급을 한 것인지 궁금하여 해당 저서를 읽어볼까 합니다.


---

## 개선해야 할 사항

**1. Service 계층을 좀 더 가볍게 만들 수 있을것 같습니다.**
  단일책임이라는 이름 하에 모든 비지니스 로직을 서비스에 위임했습니다.
  결국 service 계층에 너무나 많은 코드가 들어가게 되었습니다.
  공통된 부분은 메소드로 추출하고, 도메인 주도적으로 코드를 작성한다면, 훨씬 더 깔끔한 코드가 나올 수 있었다고 생각합니다.

**2. 아키텍쳐에 대한 추가적인 학습의 필요성**
  나름대로 설정에 대한 영역은 global 패키지로 분류하고, 실제 로직이 수행되는 영역은 data 패키지로 분류하여 하위 패키지를 설정해 보았습니다.
  data의 하위 패키지를 domain 단위로 분류하는것이 아닌 Controller, Service등 역할단위로 분류하였습니다.
  현재는 테이블이 많지않아 크게 문제는 없으나, 조금만 테이블이 많아지면 현재 패키지 구조로는 작업하기 끔찍할 것 같다는 생각이 들었습니다.

  현재는 기능구현에 대해서 집중하느라 아키텍쳐 구조에 대해선 크게 신경쓰지 않았으나,
  아키텍쳐 설계에 대해서 한번쯤 깊이있게 공부하면 더 나은 개발자로 성장할 수 있을것 같다는 생각을 하였습니다.


**3. 로그인여부 비밀번호 저장방식을 스프링 시큐리티를 사용하여  구현하겠습니다.**
  23년 02월 27일 현재. 스프링의 핵심기능을 사용해보고자 인터셉터를 사용하여 로그인 여부를 확인하였습니다.
  그러나 해당 기능은 스프링 시큐리티를 이용하면 더욱 간단하게 구현할 수 있을것 같다는 생각이 들었습니다. 
  현재 간단한 이론적인 학습은 마친 상태이며, 직접 변환 과정을 구현 하겠습니다.

---
2023.08.20
기존 포트폴리오에 담겨있던 내용을 README 파일로 복사.
